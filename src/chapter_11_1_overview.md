# Replication and Consistency

在我们开始讨论一致性跟做出原子性承诺的算法前，为了能够更深入的理解他们，先把所需的最后一块内容 *Consisitencyh Models* 一致性模型。一致性模型解释了系统中数据的多个副本的可见性语义以及行为。

容错性是指系统能够在其组件出现故障时基础保持正确的运行，创建一个具有容错性的系统并不是简单的任务，要往一个现存的系统中添加容错性就更难了。他主要的目标是移除系统中的故障单点，并确保核心的组件能够保持一定的冗余性。通常来说，冗余性对于使用者来说是透明的。

一个能够保存数据的多个副本的同时保持正确运行的系统，在有其中一些机器故障时，其他的机器能够进行故障转移处理。对于一个只有一个可信来源的系统 *(比如使用了主从模式的数据库)*，可以明确的进行故障转移，比如晋升某个副本成为新的 Master。其他的系统并不要求明确要求在处理读取跟写去请求时，通过收集多个参与者的响应来对系统进行重新配置跟确保一致性。

数据的 *Replication* 副本是某些系统通过管理数据的多个副本来实现冗余的方式。但是，因为原子性的去更新多个数据副本跟实现一致性是一样的问题，在数据库的每个步骤中都做这个处理可能会对性能造成很大的开销。我们会去了解一些更具有成本效益以及可伸缩的方式，能够去指定参与者之间允许产生的分歧级别，让用户在他们的角度上看到的数据是具有一致性的。

副本在使用了多数据中心的部署方式中尤其重要，地理上的分布的副本是为了实现下面几个目标：提高整体的可用性来承受冗余的一个或者多个数据中心的故障。他还能够通过将复制到数据放到更接近用户的地理位置来降低延迟。

当数据记录被修改时，他们对应的副本也因此需要进行更新。当我们说起副本时，我们关注三个最主要的事件是：*write* 写入、*replica update* 副本更新跟 *read* 读取。这些操作会从客户端开始触发一系列的事件。在某些场景中，更新副本可以在客户认为操作已经完成之后来执行，但这并没有改变需要客户能够观察到操作以指定的顺序执行的事实。